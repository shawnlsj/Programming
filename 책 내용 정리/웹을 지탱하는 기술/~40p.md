### 클라이언트/서버의 이점  
- 단일의 컴퓨터로 처리 X  
  -> 클라이언트와 서버로 분리하여 처리가 가능  
-> 클라이언트를 멀티플랫폼으로 할 수가 있다.
- 가용성(Availability, 可用性) 향상  
-> 복수의 서버를 조합하여 다중화가 가능하기 때문


###  클라이언트/서버에 아키텍처 스타일을 추가해보자
###  (1) Stateless Server
- Stateless?  
-> 클라이언트쪽 애플리케이션의 상태를 서버가 관리하지 않는다는 것을 의미  
-> 따라서 서버쪽 구조를 간략화시킬 수가 있음


### (2) 캐시(Cache)
- 한번 취득한 리소스를 클라이언트 측에서 돌려쓰는 방식  
-> 서버와 클라이언트의 통신량이 줄어들어, 네트워크 대역의 처리시간 감소  
-> 오래된 캐시를 이용해버려 정보의 신뢰성이 떨어질 가능성이 있음

### (3) 통일 인터페이스(Uniform Interface)
- [URI로 나타낸 리소스]를 [통일된 인터페이스]로 조작하는 아키텍처 스타일  
-> HTTP 1.1의 경우 메소드는 8개로 한정적  
-> 메소드 확장에 제한을 두어 아키텍처가 심플해짐  
- [인터페이스가 통일]되는 것으로 [클라이언트와 서버의 독립성]이 향상
- 통일 인터페이스는 REST를 가장 특징짓는 아키텍처 스타일 

### (4) 계층화 시스템
시스템을 몇 개의 계층으로 분리하는 아키텍처 스타일
* 클라이언트쪽에서 서버와 프록시 모두 같은 인터페이스로 접속가능   
-> 서버, 프록시등 컴포넌트간 인터페이스를 HTTP로 통일하고 있기 때문에

* HTTP 인터페이스가 구현되지 않은 레거시 시스템일 경우  
-> 레거시 시스템과 클라이언트 사이에 WAS를 두어 클라이언트와 접속 가능  
-> [클라이언트 - WAS - 레거시 시스템]

### (5) 코드 온 디멘드 (Code on Demand)
- 코드를 서버에서 다운받아 클라이언트측에서 실행하는 아키텍처 스타일  
- 장점  
클라이언트 프로그램을 나중에도 확장이 가능함  
-> 미리 기능을 추가해 놓지 않아도 신기능을 추가해 나갈 수 있음
- 단점  
애플리케이션 프로토콜의 가시성이 저하됨  
-> HTTP로 통신하는 경우, [통신의 의미]와 [액세스하는 리소스]가 명백함  
-> 그러나 코드 온 디멘드로 프로그램을 다운받아 클라이언트측에서 실행해버리면 프로토콜의 가시성이 저하됨

## REST를 구성하는 6개의 아키텍처 스타일
- 클라이언트/서버  
-> 유저 인터페이스와 처리를 분리
- 스테이트리스 서버  
-> 서버측에서 애플리케이션 상태를 갖지 않음  

- 캐시  
-> 클라이언트와 서버의 통신회수와 통신량을 감소
- 통일 인터페이스  
-> 인터페이스를 고정시킴
- 계층화 시스템  
-> 시스템을 계층으로 분리
- 코드 온 디멘드  
->프로그램을 클라이언트측에서 다운받아 실행

## REST의 2가지 측면
### (1) REST와 하이퍼미디어
- 애플리케이션 상태 엔진으로서의 하이퍼미디어란?  
(Hypermedia as the engine of application state, HATEOAS)  
-> 웹의 북마크 기능을 예로 들어 설명해보자

- 링크를 따라가는 작업들을 거쳐,  
전체적으로 소셜북마크라고하는 애플리케이션이 실현됨  
-> 이러한 Web의 특징을 REST에서는 HATEOAS라고 부름
- 애플리케이션 상태란?  
-> ex) 북마크 열람을 표시중, 새로운 북마크를 추가하려 하고있음  
-> 이러한 상태는 링크를 클릭하는 작업에 의해 바뀜  
-> 이것이 하이퍼미디어가 애플리케이션 상태엔진이라 불리는 이유

- 하이퍼미디어를 사용한 웹의 장점  
-> 어떤 애플리케이션 리소스의 URI만 있으면 다른 애플리케이션에서도 재사용이 가능

접속성(Connectedness)
- 링크를 통해 리소스에 접속하는 것으로 하나의 애플리케이션을 구성한다는 사고방식

### (2) REST와 분산시스템
분산오브젝트
- 네트워크 너머로 함수를 호출하여 엄청난 오버헤드를 초래함  
-> 호출회수가 많아 질수록 시스템 전체의 성능열화로 이어짐
- 기능을 추가하여 버전업 할 때마다 메소드가 늘어나거나 인수가 바뀌어서 API의 호환성을 잃어버림  
-> 기존의 클라이언트를 전부 동시에 업데이트해야하는 상황이 발생  
(Web 같은 대규모 시스템에서는 비현실적)

REST
- 링크에 접속하는 것으로 애플리케이션을 실현함  
- 리소스는 그 자체로도 의미를 갖기 때문에 입도가 큼  
-> 링크를 접속하여 애플리케이션 상태를 바꾸는 것으로 성능열화를 억누를 수 있음
- 인터페이스가 고정되어 있어 호환성 문제가 발생하지 않음


RESTful? -> REST의 제약에 따르고 있어 REST다운 것을 의미