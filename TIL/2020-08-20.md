## 지뢰찾기
***
```js
1. 흰 돌과 검은 돌로 빽빽히 채워진 바둑판이 있다.

2. 2차원 배열 board[x][y]에는 모든 각 점들에 대하여 검은돌의 여부를 나타내는 숫자가 저장되어 있다. 
(검은돌이 있는 점이면 1, 아니면 0)

3. 바둑판 위의 임의의 한 점(x, y)이 주어진다.

4. 해당 점을 제외한 주변의 8칸에는 모두 몇 개의 검은돌이 있는지 구할 수 있는 방법은 무엇이 있을까.
```
<br>
먼저 주어진 점을 (0, 0)으로 놓고 주변 점들의 상대 좌표를 구해본다.

```js
(-1,-1) (0,-1) (1,-1)
(-1, 0) (0, 0) (1, 0)
(-1, 1) (0, 1) (1, 1)
```
* 이제 반복문을 통해 board[x-1][y-1] 부터 board[x+1][y+1]까지 탐색할 수 있는 방법을 찾으면 된다. <br> (조건에 주어진 점을 제외하라고 써있으므로 board[x][y]는 포함하면 안된다.)
***
> ### 생각하기
> * 탐색의 범위는 (x-1, y-1) ~ (x+1, y+1)이다.
> * 단, 주어진 점은 포함하면 안되므로 <br>(1) 중간에 조건문으로 주어진 점을 걸러주거나<br>
(2) 처음부터 주어진 점이 포함 안되게 할 방법을 찾아야 한다.
> * 또한, 점의 위치가 바둑판의 가장자리에 포함되는 경우도 고려해야한다. <br>예를 들어, 점이 꼭지점에 위치해 있다면 탐색해야하는 점이 3개로 줄어든다.

방법1) 이중 for문 
```js
function(x, y){
    let sum = 0;
    for(let i=-1; i<=1; i++){
        for(let j=-1; j<=1; j++){
            if(i==0&&j==0) continue;
            if(board[x+i][y+j]==1) sum++;
        }
    }
    return sum;
}
```

방법2) 2개의 배열에 각각 x, y 좌표의 변화값을 저장
```js
//주어진 점 (0, 0)을 기준으로한 주변점들의 상대좌표
(-1,-1) (0,-1) (1,-1)
(-1, 0) (0, 0) (1, 0)
(-1, 1) (0, 1) (1, 1)
function (x, y){
    let sum = 0;
    //2개 배열에 (-1,-1) (-1, 0) ... (1, 1)까지의 x, y 값을 저장
    let xArr = [-1,-1,-1, 0, 0, 1, 1, 1];
    let yArr = [-1, 0, 1,-1, 1,-1, 0, 1];

    for(let i=0; i<xArr.length; i++){
        // x, y : 주어진 점의 좌표값
        // xArr, yArr : 주변 점들의 상대좌표
        // width : 가로 격자의 개수 (예시에서는 3칸)
        // height : 세로 격자의 개수 (예시에서는 3칸)
        let pointX = (x + xArr[i] + width) % width;
        let pointY = (y + yArr[i] + height) % height;

        if(board[width][height]) sum++;
    }
    return sum;
}
```

> ### 히든 케이스
 주어진 점의 위치가 바둑판의 가장자리에 
위치한 경우를 생각해보자.

방법 2의 문제점 : 각 경우에 대하여 xArr, yArr 배열을 수정하여 코드를 작성할 필요가 생긴다.

방법1을 다시 살펴보자.


```js
function(x, y){
    let sum = 0;
    // i는 x좌표의 변화량
    for(let i=-1; i<=1; i++){
        // j는 y좌표의 변화량을 나타낸다.
        for(let j=-1; j<=1; j++){
            if(i==0&&j==0) continue;
            if(board[x+i][y+j]==1) sum++;
            //문제는 점(x,y)의 위치에 따라 [x-i] 또는 [y-j]의 값이 음수가 나오거나 인덱스의 최대값을 초과한다는 것이다.
            
        }
    }
    return sum;
}
```
board의 인덱스 [x+i] 또는 [y+j]의 값이 음수가 나오거나 최대값을 초과하는 이유는 무엇일까?<br>
주어진 점(0, 0) 이 좌측 상단의 꼭지점에 있다치면, 탐색해야 할 점은 다음과 같이 3개가 된다. 
```js
(0, 0) (1, 0)
(0, 1) (1, 1)
```
하지만 위의 로직대로라면 (-1, -1) 부터 (1,1)까지 탐색하기 때문에 존재하지 않는 인덱스를 포함하게 될 수 밖에 없다.
<br><br>
그렇다면 어떠한 점이 주어지던 탐색의 범위가 적절한 값을 갖도록 조정하는 방법을 찾아보자.
> 주어진 점(x ,y)에서 (x-1,y-1) 부터 (x+1, y+1) 까지 탐색을 한다. <br>
x-1 또는 y-1은 항상 0 이상이어야 한다. <br>
x+1 또는 y+1은 항상 인덱스의 최대값 이하여야 한다.

이 조건만 만족시키도록 코드를 작성하면, 어떠한 점이 주어지든 적절하게 탐색 범위가 설정될 것이다.<br>
### 예시)
```js
function(x, y){
    let sum = 0;
    //width 가로 칸의 개수
    //height 세로 칸의 개수 
    for(let i=Math.max(i-1,0); i<=Math.min(i+1, width); i++){
        for(let j=Math.max(j-1,0); j<=Math.min(j+1, height); j++){
            if(i==0&&j==0) continue;
            if(board[x+i][y+j]==1) sum++;
        }
    }
    return sum;
}
```




#### 참고자료<br>
모던 자바스크립트 입문 - 이소 히로시 저 <br>
지뢰찾기 소스 http://www.inmensia.com/files/minesweeper1.0.html